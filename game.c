//
//  game.c
//  hw8(me)
//
//  Created by Stella Zhu on 4/2/20.
//  Copyright Â© 2020 Stella Zhu. All rights reserved.
//

#include "game.h"

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#include "gba/gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit.
# include "imag/background.h"
# include "imag/StartPage.h"
# include "imag/SchoolMan.h"
# include "imag/fullhealth.h"
# include "imag/poorhealth.h"
# include "imag/gold.h"
# include "imag/explosion.h"
# include "imag/blueghost.h"
# include "imag/redghost.h"
# include "imag/pinkghost.h"
# include "imag/orangeghost.h"
# include "imag/ham.h"
# include "imag/poorhealth.h"
# include "imag/Win.h"
# include "imag/Fail.h"
# include "imag/king.h"

/* TODO: */
// Add any additional states you need for your app.


/* Initial variables Setup*/
GBAState state = START;
GhostType ghostTypeList[] = {BLUEGHOST, REDGHOST, ORANGEGHOST, PINKGHOST};
int randomSpeed[] = {-1,-2,1,2};


Player* stellaPtrCs = &csP.stella;
Player* stellaPtrPs = &psP.stella;

Ham myHam;

//Ghost ghostList[4];

/* function prototype */
void setInitialVariables(void);
void startGame(u32, u32);
void playGame(u32, u32);
void displayGhost(struct ghostState);
void endGameWin(void);
void endGameFail(void);
void eraseGhost(struct ghostState state);
int atBorder(void);
void erasePlayerPs(void);
void erasePlayerCs(void);
void displayPlayerCs(void);
void detectConflict(void);
void detectAttack(u32, u32);
void clearGhost(void);
void displayHam(void);
void eatHam(u32, u32);
void evolveMe(void);
void checkEnding(void);


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;


  // int reset = 0; //for resetting the game

  while (1) {
    currentButtons = BUTTONS;  // Load the current state of the buttons

    waitForVBlank();
      
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) != 0) {
        state = START;
    }
      
      
    switch (state)
    {
        case START:
            startGame(previousButtons, currentButtons);
            break;
    
        case PLAY:
            playGame(previousButtons, currentButtons);
            break;
            
        case WIN:
            endGameWin();
            break;
            
        case LOSE:
            endGameFail();
            break;
    }
      
    previousButtons = currentButtons;  // Store the current state of the buttons
  }

  UNUSED(previousButtons);  // You can remove this once previousButtons is used

  return 0;
}

/* ================================================================= */
/* mode = START */
void startGame(u32 previousButtons, u32 currentButtons) {
    drawFullScreenImageDMA(StartPage);
    char * str = "PRESS <START/ENTER> TO START!!";
    drawString(150, 30, str, YELLOW);
    currentButtons = BUTTONS;
    delay(200);
    if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons) != 0) {
        drawString(150, 30, str, RED);
        state = PLAY;
    }
}

/* ================================================================= */
/* mode = PLAY */
void playGame(u32 previousButtons, u32 currentButtons) {
    /* display basic background */
    fillScreenDMA(BLACK);
    delay(2);
    drawFullScreenImageDMA(background);
    char * promptStr = "<SELECT>: RESUME <A>: ATTACK";
    drawString(150, 10, promptStr, YELLOW);
    
    /* set intial values */
    setInitialVariables();
    
    /* initialize health level of the player */
    plzBeTranparent(0, 210, 10, 10, fullhealth); //No.1 heart
    plzBeTranparent(0, 220, 10, 10, fullhealth); //No.2 heart
    plzBeTranparent(0, 230, 10, 10, fullhealth); //No.3 heart
    
    /* intialize explosion counter */
    plzBeTranparent(0, 5, 20, 20, explosion); // THE explsion sign
    drawChar(5, 30, 9 + 48, BLUE);
    
    
    /* display ghosts */
    displayGhost(csG);
    
    /* display hamburgers */
    
    
    /* movement part */
    while (1) {
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) != 0) {
            state = START;
            break;
        }
        
        currentButtons = BUTTONS;
        
        /* update state */
        psP = csP;
        psG = csG;
        
        /* check state */
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) != 0) {
            state = START;
            break;
        }
        
        /* move ghosts */
        for (int i = 0; i < 4; i++) {
            csG.ghostList[i].row += csG.ghostList[i].rd;
            csG.ghostList[i].col += csG.ghostList[i].cd;
            
            if (csG.ghostList[i].row < 20) {
                csG.ghostList[i].row = 20;
                csG.ghostList[i].rd *= -1;
            }
            if (csG.ghostList[i].row > (149 - csG.ghostList[i].height + 1)) {
                csG.ghostList[i].row = 149 - csG.ghostList[i].height + 1;
                csG.ghostList[i].rd *= -1;
            }
            if (csG.ghostList[i].col < 0) {
                csG.ghostList[i].col = 0;
                csG.ghostList[i].cd *= -1;
            }
            if (csG.ghostList[i].col > (239 - csG.ghostList[i].width + 1)) {
                csG.ghostList[i].col = 239 - csG.ghostList[i].width + 1;
                csG.ghostList[i].cd *= -1;
            }
            
            waitForVBlank();
            if (! (csG.ghostList[i].dead)) {
                eraseGhost(psG);
                displayGhost(csG);
            } else if (! csG.ghostList[i].erased) {
                eraseGhost(psG);
                csG.ghostList[i].erased = 1;
            }
        }
        
        /* display ham */
        displayHam();
        
        /* manipulate player */
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) != 0) {
            if (!atBorder()) {
                stellaPtrCs -> row -= stellaPtrCs -> speed;
            }
        }
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) != 0) {
            if (!atBorder()) {
                stellaPtrCs -> row += stellaPtrCs -> speed;
            }
        }
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) != 0) {
            if (!atBorder()) {
                stellaPtrCs -> col -= stellaPtrCs -> speed;
            }
        }
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) != 0) {
            if (!atBorder()) {
                stellaPtrCs -> col += stellaPtrCs -> speed;
            }
        }
        
        waitForVBlank();
        erasePlayerPs();
        displayPlayerCs();
        
        detectConflict();
        if (state == LOSE) {
            break;
        }
        detectAttack(currentButtons, previousButtons);
        clearGhost();
        drawRectDMA(5, 30, 6, 20, WHITE);
        if (stellaPtrCs -> attackCounter <= 9) {
            drawChar(5, 30, 9 - stellaPtrCs -> attackCounter + 48, BLUE);
        }
        eatHam(currentButtons, previousButtons);
        evolveMe();
        
        if (9 - stellaPtrCs -> attackCounter <= 0) {
            state = LOSE;
            break;
        } else {
            int k = 1;
            for (int i = 0; i < 4; i++) {
                if (!(csG.ghostList[i].dead)) {
                    k = 0;
                    break;
                }
            }
            if (k) {
                state = WIN;
                break;
            }
        }
        
        previousButtons = currentButtons;
    }
}

/* Initial Values Setup */
void setInitialVariables(void) {
    /*Player stella*/
    stellaPtrCs -> width = 20;
    stellaPtrCs -> height = 20;
    stellaPtrCs -> row = randint(0, (HEIGHT - stellaPtrCs -> height + 1));
    stellaPtrCs -> col = randint(0, (WIDTH - stellaPtrCs -> width + 1));
    stellaPtrCs -> speed = 15;
    stellaPtrCs -> health = 30;
    stellaPtrCs -> damage = 5;
    stellaPtrCs -> gold = 0;
    stellaPtrCs -> evolved = 0; //not evolved
    stellaPtrCs -> image = (u16 *)SchoolMan;
    stellaPtrCs -> attackCounter = 0;
    
    /*A list of ghosts*/
    for (int i = 0; i < 4; i++) {
        csG.ghostList[i].width = 10;
        csG.ghostList[i].height = 10;;
        csG.ghostList[i].row = randint(i, (HEIGHT - csG.ghostList[i].height + 1));
        csG.ghostList[i].col = randint(i, (WIDTH - csG.ghostList[i].width + 1));
        csG.ghostList[i].rd = randomSpeed[randint(0,3)];
        csG.ghostList[i].cd = randomSpeed[randint(0,3)];
        csG.ghostList[i].health = 15;
        csG.ghostList[i].damage = 2;
        csG.ghostList[i].realmRadius = 3;
        csG.ghostList[i].ghostType = ghostTypeList[i];
        csG.ghostList[i].erased = 0;
    }
    
    /* ham */
    myHam.col = randint(20, 220);
    myHam.row = randint(30, 100);
    myHam.height = 10;
    myHam.height = 10;
    myHam.eaten = 0;
    myHam.erased = 0;
}

/* helper methods to display ghost*/
void displayGhost(struct ghostState state) {
    for (int i = 0; i < 4; i++) {
        switch (csG.ghostList[i].ghostType) {
            case BLUEGHOST:
                if (!state.ghostList[i].dead) {
                    plzBeTranparent(state.ghostList[i].row, state.ghostList[i].col, 10, 10, blueghost);
                }
                break;
            case REDGHOST:
                if (!state.ghostList[i].dead) {
                    plzBeTranparent(state.ghostList[i].row, state.ghostList[i].col, 10, 10, redghost);
                }
                break;
            case ORANGEGHOST:
                if (!state.ghostList[i].dead) {
                    plzBeTranparent(state.ghostList[i].row, state.ghostList[i].col, 10, 10, orangeghost);
                }
                break;
            case PINKGHOST:
                if (!state.ghostList[i].dead) {
                    plzBeTranparent(state.ghostList[i].row, state.ghostList[i].col, 10, 10, pinkghost);
                }
                break;
        }
    }
}

void eraseGhost(struct ghostState state) {
    for (int i = 0; i < 4; i++) {
        switch (csG.ghostList[i].ghostType) {
            case BLUEGHOST:
                eraseImage(state.ghostList[i].row, state.ghostList[i].col, 10, 10, blueghost, background);
                break;
            case REDGHOST:
                eraseImage(state.ghostList[i].row, state.ghostList[i].col, 10, 10, redghost, background);
                break;
            case ORANGEGHOST:
                eraseImage(state.ghostList[i].row, state.ghostList[i].col, 10, 10, orangeghost, background);
                break;
            case PINKGHOST:
                eraseImage(state.ghostList[i].row, state.ghostList[i].col, 10, 10, pinkghost, background);
                break;
        }
    }
}

/* helper methods to display player*/
void displayPlayerCs(void) {
    plzBeTranparent(stellaPtrCs -> row, stellaPtrCs -> col, 20, 20, stellaPtrCs -> image);
}

void erasePlayerCs(void) {
    eraseImage(stellaPtrCs -> row, stellaPtrCs -> col, 20, 20, stellaPtrCs -> image, background);
}

void erasePlayerPs(void) {
    eraseImage(stellaPtrPs -> row, stellaPtrPs -> col, 20, 20, stellaPtrCs -> image, background);
}

/* helper method to check if the player needs to turn */
int atBorder(void) {
    if (stellaPtrCs -> row < 25) {
        stellaPtrCs -> row = 25;
        return 1;
    }else if (stellaPtrCs -> col > (239 - stellaPtrCs -> height + 1)) {
        stellaPtrCs -> col = 239 - stellaPtrCs -> height + 1;
        return 1;
    }else if (stellaPtrCs -> col < 0) {
        stellaPtrCs -> col = 0;
        return 1;
    }else if (stellaPtrCs -> row > (129 - stellaPtrCs -> width + 1)) {
        stellaPtrCs -> row = 129 - stellaPtrCs -> width + 1;
        return 1;
    } else {
        return 0;
    }
    
}

/* helper method to detect conflicts */
void detectConflict(void) {
    for (int i = 0; i < 4; i++) {
        int upperHeight = stellaPtrCs -> row + 3;
        int lowerHeight = stellaPtrCs -> row + csG.ghostList[i].height - 3;
        int leftWidth = stellaPtrCs -> col + 3;
        int rightWidth = stellaPtrCs -> col + csG.ghostList[i].width - 3;
        if ((csG.ghostList[i].row > upperHeight && csG.ghostList[i].row < lowerHeight)
            && (csG.ghostList[i].col > leftWidth && csG.ghostList[i].row < rightWidth)
            && !(csG.ghostList[i].dead)) {
            for (int i = 0; i < 100; i++) { //when attacked
                erasePlayerCs();
                displayPlayerCs();
            }
            stellaPtrCs -> health -= csG.ghostList[i].damage;
            int healthLevel = stellaPtrCs -> health % 10;
            if (stellaPtrCs -> health == 0) {
                state = LOSE;
                break;
            }
            switch (healthLevel) {
                case 2:
                    plzBeTranparent(0, 230, 10, 10, poorhealth);
                    break;
                case 1:
                    plzBeTranparent(0, 220, 10, 10, poorhealth);
                    plzBeTranparent(0, 230, 10, 10, poorhealth);
                    break;
                case 0:
                    plzBeTranparent(0, 210, 10, 10, poorhealth);
                    plzBeTranparent(0, 220, 10, 10, poorhealth);
                    plzBeTranparent(0, 230, 10, 10, poorhealth);
                    break;
                default:
                    break;
            }
        }
    }
}

/* helper method to detect attack to ghosts from player*/
void detectAttack(u32 currentButtons, u32 previousButtons) {
    if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons) != 0
        && stellaPtrCs -> attackCounter < 9) {
        for (int i = 0; i < 4; i++) {
            int upperHeight = stellaPtrCs -> row - 5;
            int lowerHeight = stellaPtrCs -> row + csG.ghostList[i].height + 5;
            int leftWidth = stellaPtrCs -> col - 5;
            int rightWidth = stellaPtrCs -> col + csG.ghostList[i].width + 5;
            if ((csG.ghostList[i].row > upperHeight && csG.ghostList[i].row < lowerHeight)
                && (csG.ghostList[i].col > leftWidth && csG.ghostList[i].row < rightWidth)
                && !(csG.ghostList[i].dead)) {
                csG.ghostList[i].health -= stellaPtrCs -> damage;
                stellaPtrCs -> attackCounter ++;
                plzBeTranparent(csG.ghostList[i].row, csG.ghostList[i].col, 20, 20, explosion);
                delay(200);
                eraseImage(csG.ghostList[i].row, csG.ghostList[i].col, 20, 20, explosion, background);
            }
        }
    }
}

/* helper method to eat ham */
void eatHam(u32 currentButtons, u32 previousButtons) {
    if (KEY_JUST_PRESSED(BUTTON_L, currentButtons, previousButtons) != 0) {
        int upperHeight = stellaPtrCs -> row - 5;
        int lowerHeight = stellaPtrCs -> row + myHam.height + 5;
        int leftWidth = stellaPtrCs -> col - 5;
        int rightWidth = stellaPtrCs -> col + myHam.width + 5;
        if ((myHam.row > upperHeight && myHam.row < lowerHeight)
            && (myHam.col > leftWidth && myHam.row < rightWidth)) {
            myHam.eaten = 1;
//            stellaPtrCs -> attackCounter ++;
        }
    }
}

/* helper method to clear dead ghosts*/
void clearGhost(void) {
    for (int i = 0; i < 4; i++) {
        if (csG.ghostList[i].health <= 0) {
            csG.ghostList[i].dead = 1;
        }
    }
}

/* helper methods to display hamburgers */
void displayHam(void) {
    if (! myHam.eaten) {
        plzBeTranparent(myHam.row, myHam.col, 10, 10, ham);
    } else if (! myHam.erased) {
        eraseImage(myHam.row, myHam.col, 10, 10, ham, background);
        myHam.erased = 1;
    }
}

/* helper methods to evolve the player into king */
void evolveMe(void){
    if (myHam.eaten && ! stellaPtrCs -> evolved) {
        eraseImage(stellaPtrCs -> row, stellaPtrCs -> col, 20, 20, SchoolMan, background);
        stellaPtrCs -> image = (u16 *)king;
        for (int i = 0; i < 4; i++) {
            csG.ghostList[i].damage = 1;
        }
        stellaPtrCs -> damage = 10;
        stellaPtrCs -> health = 50;
        stellaPtrCs -> evolved = 1;
    }
}

void checkEnding(void) {
    if (9 - stellaPtrCs -> attackCounter > 0) {
        state = LOSE;
    } else {
        int k = 1;
        for (int i = 0; i < 4; i++) {
            if (!(csG.ghostList[i].dead)) {
                k = 0;
                break;
            }
        }
        if (k) {
            state = WIN;
        }
    }
}

/* ================================================================= */
/* end game if win */
void endGameWin(void) {
    drawFullScreenImageDMA(Win);
    char * str = "        CONGRATS YOU WIN!         ";
    drawString(140, 10, str, WHITE);
}

/* ================================================================= */
/* end game if fail */
void endGameFail(void) {
    drawFullScreenImageDMA(Fail);
    char * str = "          YOU LOSE :(         ";
    drawString(140, 10, str, WHITE);
}
